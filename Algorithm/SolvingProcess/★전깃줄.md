# 검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음검색했음

# 전깃줄
## 유형 : 동적계획법 (DP)
* [2565](https://www.acmicpc.net/problem/2565) [:page_facing_up:](https://github.com/knemo333/TIL/blob/master/Algorithm/codes/2565.cpp)


### 문제
전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때, 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.

#### 접근방법1
> LIS 활용해서 가장 긴 꼬이지 않는 갯수 세고 그것을 전체 갯수에서 빼면 되지 않을까? 가 잘안됨 개짜증남진짜

#### 접근방법2
> 검색했음 왼쪽정렬하고 오른쪽 LIS찾기임 진짜 개짜증남

##### 코드
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
	int n;
	vector<pair<int, int>> inputVector;
	int memo[100] = {0,};

	cin >> n;

	for (int i = 0; i < n; i++) {
		int a, b;
		cin >> a >> b;
		inputVector.push_back(pair<int, int>(a, b));
	}

	sort(inputVector.begin(), inputVector.end());

	for (int i = 0; i < n; i++) {
		int temp = 0;
		for (int j = 0; j <= i; j++) {
			if (i == j)
				memo[i] = temp + 1;

			if (inputVector[j].second < inputVector[i].second && temp < memo[j])
				temp = memo[j];
		}
	}

	cout << n - *max_element(memo, memo + n);
}
```

### 결론
아그냥개짜증나는문제   
진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가진짜나는개빡대가리인가